```
设计电商秒杀系统
【业务背景】
你作为一个电商创业公司的架构师，负责设计6.18大促秒杀系统的设计，你们的业务模式如下：
1. 你们挑选选品各大电商平台上畅销和好评的商品进行销售，每个品类不超过20个商品，目前做了10个品类；
2. 本次6.18秒杀选择了1000个充电宝，10台iPhone 12 作为秒杀商品；
3. 正常的日活大约100万用户；
4. 老板要求万无一失。
【技术背景】
1. 技术团队以Java 为主，已经落地了微服务架构；
2. 主要渠道是自有的App（包括iOS 和Android）和微信小程序，为了促进用户转化为App 用户，只有下载App 才能参加秒杀活动；
3. 目前只有单机房。
【毕设要求】
1. 设计完整的架构，例如存储、负载均衡、缓存、高可用、可扩展等；
2. 大约10页以内的PPT，每页PPT 说明一项设计，包括架构设计和设计理由，无需详细解释备选方案。
【提示】
1. 分析考虑要全面，但并不意味着架构设计要面面俱到，如果分析后认为某些设计点可以不做，就在作业最后统一说明原因即可；
2. 如果没有思路，请对照模块9的IM 案例；
3. 如果有的信息觉得不够全或者不够细，可以做出一定的假设，但不能天马行空，需要对照已有的业务背景和技术背景进行合理推断。
```

```
一、	业务场景分析
秒杀系统特点：
1、访问请求数量远大于库存量，只有少部分用户能够秒杀成功
2、秒杀时大量用户会在同一时间同时进行抢购，网站瞬时访问流量激增
3、秒杀业务流程比较简单，主要就是下订单减库存
秒杀系统需要优先保障的核心业务TOP3为：登录、订单、支付
正常的日活大约100万用户，老板要求万无一失 以200w计算
订单处理tps最高峰估算假设每个人点3次秒杀（通过限制） 假设参加秒杀人数为80%  
秒杀活动，可能活动持续10秒，但是商品太少1秒内就抢光了，那么在这个秒杀活动的并发量集中发生和提现在了头1秒，其余的9秒也有qps，但远不及头1秒爆发给系统所带来的冲击大，但最后运营统计的话，他统计的是10秒的量，比如这10秒总共是200w*75%的量，那么就是能够承受150w的并发系统，可能头1秒就承担了150w*60%的tps ，故假设峰值tps为90wtps/s LVS 可以抗住几十 w 的并发，通过前端加合法性验证（比如验证码，防机器人）以及后端通过限制同uid访问频率，到达 LVS 可以抵挡全部合法流量。
秒杀系统为典型的读场景 下订单后仅修改商品量1010次故采用多级缓存
二、	总体架构思路
将请求拦截在系统上游，降低下游压力：秒杀系统特点是并发量极大，但实际秒杀成功的请求数量却很少，所以如果不在前端拦截很可能造成数据库读写锁冲突，甚至导致死锁，最终请求超时
充分利用缓存：利用缓存预减库存，拦截掉大部分请求 
消息队列：这是一个异步处理过程，后台业务根据自己的处理能力，从消息队列中主动的拉取请求消息进行业务处理
核心设计思路：动静分离、热点优化、服务性能提升
主要分三个方面避免出现高性能、高可用和数据一致性的问题
1、高性能
避免日常生活以及常见业务问题出发，秒杀是要求能承受高IOPS的系统，主要将高读尽量少次读、读少量数据，高写就数据拆分
2、高可用
服务隔离；熔断+降级；限流+排队、流量削峰、异步处理；从架构落地全局统筹：考虑系统的可扩展性和容错性，避免出现单点问题。（最好是多地单元化部署，即使IDC故障也不会影响到系统运转Ps.技术背景只有单机房暂不考虑）
3、数据一致性
库存
三、	架构设计方案：
思维导图
https://www.processon.com/view/link/633db1db6376891c6b4181a1

秒杀系统架构图
https://processon.com/diagraming/633f08b17d9c080c4240613d

前端方案
页面静态化：将活动页面上的所有可以静态的元素全部静态化，并尽量减少动态元素。通过LVS负载均衡来抗峰值。 
禁止重复提交：用户提交之后按钮置灰，禁止重复提交 
用户限流：在某一时间段内只允许用户提交一次请求，比如可以采取IP限流

后端方案
服务端控制器层(网关层)
限制uid（UserID）访问频率3次：我们上面拦截了浏览器访问的请求，但针对某些恶意攻击或其它插件，在服务端控制层需要针对同一个访问uid，限制访问频率。

服务层
上面只拦截了一部分访问请求，当秒杀的用户量很大时，即使每个用户只有一个请求，到服务层的请求数量还是很大。比如我们有100W用户同时抢100台手机，服务层并发请求压力至少为100W。

1、把需要秒杀的商品的主要信息以及库存初始化到redis缓存中
2、做请求合法性的校验（比如是否登录），如果请求非法，直接给前端返回错误码，进行相应的提示
3、进行内存标识的判断(true 已经秒杀结束，false 未秒杀结束，下面第4步会写入)，如果内存标识为true，直接返回秒杀结束
4、redis中使用decr 进行预减库存操作，判断：如果decr后库存量小于0，则把内存标记置为true(已经秒杀结束，第3步会用到)，且返回秒杀结束
5、用redis的布隆过滤器来判断是否已经秒杀到了（下面第7步会写入），防止重复秒杀，如果重复秒杀，直接返回重复秒杀的错误码。具体做法是：先用redis的布隆过滤器来判断是否秒杀过，如果布隆过滤器判断已经秒杀过了， 则再次查库确认是否秒杀过了，之所以再次查库确认是因为布隆过滤器对可能存在的数据是有误判率的；但是它对不存在的数据的判断是百分百准确的，所以如果redis的布隆过滤器判断没秒杀过，就直接放过去进行秒杀
6、发送成功秒杀到的MQ消息给相应的业务端进行处理，并给用户端返回排队中，如果客户端收到排队中的消息，则自动进行轮询查询，直到返回秒杀成功或者秒杀失败为止
7、相应的业务端进行处理：真正处理秒杀的业务端，再次进行校验（比如秒杀是否结束，库存是否充足等）、将用户和商品id作为key存入redis的布隆过滤器来标识该用户秒杀该商品成功（第5步会用到）、减库存（这里的是真正的减库存，操作数据库的库存）、生成秒杀订单、返回秒杀成功

注意：就算请求走到了真正处理业务的这一端，也有可能秒杀失败，比如秒杀结束，库存不足，真正减库存失败，秒杀单生成失败等等，一旦失败，则返回秒杀结束

优化：将秒杀接口隐藏：用户点击秒杀按钮的时候，根据用户id生成唯一的加密串存入缓存并返回给客户端，然后客户端再次请求的时候带着加密串过来，后端进行校验是否合法，若不合法，直接返回请求非法；

限制某个接口的访问频率：可以用拦截器配合自定义注解来实现，这么做可以和具体的业务分离减少入侵，使用起来也非常方便

数据库层
数据库层是最脆弱的一层，一般在应用设计时在上游就需要把请求拦截掉，数据库层只承担“能力范围内”的访问请求。所以，上面通过在服务层引入队列和缓存，让最底层的数据库高枕无忧

为防止秒杀出现负数订单数大于真正的库存数，所以在真正减库存，update库存的时候应该加上where 库存>0，而且需要给秒杀订单表加上用户id和商品id联合的唯一索引

```
